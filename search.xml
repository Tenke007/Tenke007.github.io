<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[微信扫码登录第三方网站的两种实现思路]]></title>
      <url>%2F2017%2F03%2F08%2Fwechat-scan-login%2F</url>
      <content type="text"><![CDATA[一、利用微信公众服务号带参数二维码功能实现微信扫码登录。（mp.weixin.qq.com）原理思路：1、通过调用公众号带参数二维码接口产生二维码，同时在数据表中保存scene_id(场景值)2、用户扫描带参数二维码进入微信公众号，未关注则显示关注，已关注则直接进入公众号3、微信公众号后台接收微信推送关注事件或者扫码事件，获取用户的openid以及scene_id(场景值)，然后保存openid到对应的scene_id记录表中。4、前端通过ajax长轮循方式去找scene_id记录表中的openid，如果有openid则进行下一步判断：注册（通过openid调用接口来获取用户信息）、登录或者是绑定账号，如果没有openid则间隔一段时间又重新发起请求。 二、微信开放平台下网站应用的一种接口实现的功能。（open.weixin.qq.com）原理思路：1、在微信开放平台注册开发者帐号，并拥有一个已审核通过的网站应用，并获得相应的AppID和AppSecret，申请微信登录且通过审核后，可开始接入流程。2、在微信用户授权登录已接入微信OAuth2.0的第三方应用后，第三方可以获取到用户的接口调用凭证（access_token），通过access_token可以进行微信开放平台授权关系接口调用，从而可实现获取微信用户基本开放信息和帮助用户实现基础开放功能等。微信OAuth2.0授权登录目前支持authorization_code模式，适用于拥有server端的应用授权。该模式整体流程为：（1）第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；（2）通过code参数加上AppID和AppSecret等，通过API换取access_token；（3）通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。 结论：第一种方式是微信的开放平台的接口还没出来之前的一种实现逻辑思路，技术点实现起来麻烦，网站要跟公众号后台对接实现数据更新，还需要轮询判断用户有没有扫码。 第二种方式显然简单方便，只需要微信开放平台开发者帐号，开发流程和公众号网页授权原理一样，用户授权，就可以直接调接口获取用户的信息来完成注册或者登录。开发者只需要写好回调接口，不需要判断用户有没有扫码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP Session会话和安全]]></title>
      <url>%2F2017%2F03%2F06%2Fphp-session%2F</url>
      <content type="text"><![CDATA[php.ini中关于Session安全部分的说明 ● session.cookie_lifetime=0。 0 表示特殊含义，它告知浏览器不要持久化存储 cookie 数据。 也即，关闭浏览器的时候，会话 ID cookie 会被立即删除。 如果将此项设置为非 0 的值，可能会导致会话 ID 被其他用户使用。 大部分应用应该把此项设置为“0”。 如果应用中有自动登录的功能，请自行实现一种更加安全的方式，而不要使用会话 ID 来完成自动登录。 ● session.use_cookies=On 并且 session.use_only_cookies=On。 虽然 HTTP cookie 存在一些问题， 但是它确实是实现会话 ID 管理的优选方案。 尽可能的仅使用 cookie 来进行会话 ID 管理， 而且大部分应用也确实是只使用 cookie 来记录会话 ID 的。 ● session.use_strict_mode=On。 此设置防止会话模块使用未初始化的会话 ID。 也就是说， 会话模块仅接受由它自己创建的有效的会话 ID， 而拒绝由用户自己提供的会话 ID。 使用 JavaScript 对 cookie 进行注入 就可以实现对会话 ID 的注入， 甚至可以在 URL 的查询字符串中或者表单参数中实现会话 ID 的注入。 大部分应用没理由也不应该接受由用户提供的未经初始化的会话 ID。 ● session.cookie_httponly=On。 禁止 JavaScript 访问会话 cookie。 此设置项可以保护 cookie 不被 JavaScript 窃取。 虽然可以使用会话 ID 来作为防范跨站请求伪造（CSRF）的关键数据， 但是不建议你这么做。 例如，攻击者可以把 HTML 源代码保存下来并且发送给其他用户。 为了安全起见， 开发者不应该在 web 页面中显示会话 ID。 几乎所有的应用都应该对会话 ID cookie 设置 httponly 为 On。 ● session.cookie_secure=On。 仅允许在 HTTPS 协议下访问会话 ID cookie。 如果你的 web 站点仅支持 HTTPS，那么必须将此选项设置为 On。 对于仅支持 HTTPS 的 web 站点建议考虑使用强制安全传输技术（HSTS）。 ● session.gc_maxlifetime=[尽可能的小]。 GC 的运行时机并不是精准的，带有一定的或然性，所以这个设置项并不能确保 旧的会话数据被删除。某些会话存储处理模块不使用此设置项。 更多的信息请参考会话存储模块的完整文档。 虽然开发人员不能完全依赖这个设置，但是还是建议将其设置的尽可能的小。 调整 session.gc_probability 和 session.gc_divisor 设置项 可以使得过期的会话数据在适当的周期内被删除。 如果需要使用自动登录的功能，请使用其他更加安全的方式自行实现， 而不要通过使用长生命周期的会话 ID 来实现。 ● session.use_trans_sid=Off。 如果确实需要， 你也可以使用透明的会话 ID 管理。 禁用透明会话 ID 管理可以提高安全性， 规避会话 ID 注入和泄露的风险。 ● session.referer_check=[你的源 URL] 当启用 session.use_trans_sid 设置项时， 建议尽可能的联合使用此设置项来降低会话 ID 注入的风险。 假设你的站点是 http://example.com/， 请将此设置项置为 http://example.com/。 需要注意的，如果使用 HTTPS ， 浏览器将不会发送 referrer 请求头， 因此，从安全角度考虑，此设置项并不总是可信赖的。 ● session.cache_limiter=nocache。 确保对于已经认证的会话， 其 HTTP 内容不被缓存。 你应仅允许缓存公开的内容， 否则将面临内容暴露的风险。 如果 HTTP 内容中不包含安全信息或敏感数据，可以使用“private”。 注意，“private”可能会导致客户端缓存私有数据。 仅在 HTTP 内容中不包含任何私有数据的时候，可以使用“public”。 ● session.hash_function=”sha256”。 高强度的散列函数可以产生高强度的会话 ID。 虽然即使是使用 MD5 散列算法，要找到相同的散列值也是非常不易的， 但是开发人员还是应该选择 SHA-2 或者更高的散列算法， 例如可以使用 sha384 或者 sha512。 会话模块无法保证存储到会话中的数据仅能被会话创建者可见。 如果要保护会话的完整性， 你需要进行一些额外的工作。 至于如何保护会话，取决于你在会话中所存储的数据。 要保护会话中的数据，通常有额外的成本， 并且有可能影响用户使用的便利性。 例如，要想防范简单的社会工程学方式的攻击， 你需要启用 session.use_only_cookies。 这样一来， 用户需要无条件的接受 cookie， 否则会话功能将无法正常工作。 有几种方式可以将会话 ID 泄露给第三方。 会话 ID 的泄露会导致 第三方可以访问该会话 ID 所关联的所有资源。 如果从你的站点链接到外部站点， 在 URL 中所携带的会话 ID 可能会被外部站点的 “referrer”日志记录。 其次，更加主动的攻击者会尝试监听你的网络通信， 明文传输的会话 ID 可能会被攻击者从网络层面窃取。 对于这种场景的解决方案是在服务器使用 SSL 通信， 并且强制用户使用 SSL 方式访问你的服务。 自 PHP 5.5.2 开始，可以使用 session.use_strict_mode 设置项。当启用该设置项，并且会话保存管理器能够支持此设置项的话， 它会拒绝未经初始化的会话 ID 并且返回一个新创建的会话 ID。 通过强制用户使用新的会话 ID，可以避免遭受攻击。 如果启用了 session.use_trans_sid 设置项，攻击者可以发送包含会话 ID 的 URL 给受害者， 例如：http://example.com/page.php?PHPSESSID=123456789， 那么受害者将会使用攻击者提供的会话 ID 开始会话。 session.use_strict_mode 设置项可以降低这样的风险。虽然 session.use_strict_mode 设置项可以降低风险， 攻击者依然可以使用自己创建的、已经经过初始化的会话 ID 来欺骗受害人。 只是攻击者需要在发起攻击之前初始化会话 ID 并且要保持这个会话处于活跃状态。 可以对会话 ID cookie 设置 domain，path，httponly，secure 等属性， 但是浏览器中有优先级定义， 攻击者可以利用这个特点设置可以永久使用的会话 ID。 使用 session.use_only_cookies 设置项无法解决此问题。session.use_strict_mode 设置项可以降低风险，当 session.use_strict_mode 为 “On”时，服务器将拒绝未经初始化的会话 ID， 而是返回一个新创建的会话 ID。 这可能会导致受害者面临 DoS 攻击，但是总好过账号被盗取。 session.use_strict_mode 设置项可以缓解这种情况， 但是对于已经经过认证的会话，它就有些力不从心了。 开发人员必须使用 session_regenerate_id() 来进行认证， 并且还需要在向 $_SESSION 中存储认证信息之前调用 session_regenerate_id() 函数。session_regenerate_id() 可以确保仅在新会话中存储认证后的信息。 例如，如果在认证过程中发生错误， 可能会在旧的会话中保存认证通过的标识。 和 use_strict_mode=On 类似，使用session_regenerate_id() 函数 也可能导致 DoS 攻击（从个人角度来看），但是总好过账号被盗取。 至少应该在用户通过认证之后为其重新生成新的会话 ID。 重新生成会话 ID 可以降低被窃取的风险， 所以应该定期重新生成会话 ID。 开发人员不应依赖会话过期， 因为攻击者可以通过定期使用受害者会话 ID 发起访问以保持会话活跃。 开发人员必须自行实现针对过期会话的处理。 需要提醒的是，默认情况下，session_regenerate_id() 函数并不会删除旧的会话。 对用户而言，原有的已认证的会话可能仍然可用。 如果开发人员需要阻止其他人使用原有的已认证会话， 需要设置 delete_old_session 参数为 TRUE。 但是立即删除旧的会话可能会带来其他影响， 比如在并发访问或者网络不稳定的情况下， 可能会导致会话无效。（译注：意指浏览器携带旧的会话 ID 发起了并发的请求，如果在第一个被服务器接受和处理的请求中删除了旧的会话数据，那么后续的请求将会产生会话无效的问题） 可以在 $_SESSION 中设置一个很短的过期时间来代替直接删除旧的会话， 并且拒绝用户访问旧的会话（过期的会话）。 session.use_only_cookies 和 session_regenerate_id() 联合使用， 在某些情况下可能导致针对个人的 DoS 攻击。 如果发生这种情况， 你可以告知用户清除浏览器的 cookie 并且警告用户可能存在安全隐患。 攻击者可以利用 web 应用的弱点（例如，JavaScript 注入） 或恶意的浏览器插件生成恶意的 cookie。 开发人员一定不要使用长生命周期会话 ID 来实现自动登录的功能， 因为这样会使会话很容易被窃取。 开发人员需要自行实现自动登录的功能， 可以使用比 SHA-2 更安全的散列算法， 例如 SHA-256 或者更高， 并且包含从 /dev/urandom 产生随机数据。 如果用户尚未认证通过，就检查一次性自动登录密钥是否有效。 如果密钥有效，那么对用户进行认证，并且设置新的、安全的散列值。 自动登录密钥的生存周期比认证密钥的更长， 所以要竭尽所能来保护自动登录密钥的安全。 至于 cookie，可以使用 path/httponly/secure 等属性来进行保护。 同时，开发人员还必须为用户提供禁用自动登录以及移除不再使用的自动登录密钥 cookie 的功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[冒泡排序、选择排序、插入排序以及二分法查找算法]]></title>
      <url>%2F2017%2F03%2F06%2FSorting%2F</url>
      <content type="text"><![CDATA[冒泡排序冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。选择排序选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。插入排序插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。二分法查找算法二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package demo;public class helloworld &#123; public static void main(String[] args) &#123; //int a[] = &#123;10,20,4,30,11,80,100,22&#125;; int a[] = &#123;1,3,4,5,6,7,8,19,20,100,222,230&#125;; //bubbleSort(a); binarySearch(a,5); //selectSort(a); //insertSort(a); &#125; //冒泡排序 public static void bubbleSort(int a[])&#123; int temp = 0; for(int i=1;i&lt;a.length;i++)&#123; for(int j=0;j&lt;a.length-1;j++)&#123; if(a[j]&lt;a[j+1])&#123; temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125; System.out.println(""); System.out.println("冒泡排序:"); for(int x : a)&#123; System.out.print(x+" "); &#125; &#125; //选择排序 public static void selectSort(int a[])&#123; int x=0,y=0; for(int i=0;i&lt;a.length-1;i++)&#123; x=i;y=a[i]; for(int j=i+1;j&lt;a.length;j++)&#123; if(y&lt;a[j])&#123; y=a[j]; x=j; &#125; &#125; if(y!=a[i])&#123; a[x] = a[i]; a[i] = y; &#125; &#125; System.out.println(""); System.out.println("选择排序:"); for(int k : a)&#123; System.out.print(k+" "); &#125; &#125; //选择排序1 public static void selectSort1(int a[])&#123; int temp; for(int i=0;i&lt;a.length-1;i++)&#123; for(int j=i+1;j&lt;a.length;j++)&#123; if(a[i]&lt;a[j])&#123; temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; &#125; System.out.println(""); System.out.println("选择排序1:"); for(int k : a)&#123; System.out.print(k+" "); &#125; &#125; //插入排序 public static void insertSort(int a[])&#123; int x=0,y=0; for(int i=1;i&lt;a.length;i++)&#123; if(a[i] &gt; a[i-1])&#123; x=a[i]; y = i-1; while(y&gt;=0 &amp;&amp; x&gt;a[y])&#123; a[y+1] = a[y]; y--; &#125; a[y+1] = x; &#125; &#125; System.out.println(""); System.out.println("插入排序:"); for(int k : a)&#123; System.out.print(k+" "); &#125; &#125; //二分法查找（递归） public static void binarySearch(int a[],int left,int right,int find)&#123; if(right&gt;=left)&#123; int mid = (right+left)/2; if(find == a[mid])&#123; System.out.print("找到了,第"+(mid+1)+"位"); &#125;else if(find &gt; a[mid])&#123; binarySearch(a,mid+1,right,find); &#125;else if(find &lt; a[mid])&#123; binarySearch(a,left,mid-1,find); &#125; &#125;else&#123; System.out.print("没找到"); &#125; &#125; //二分法查找（循环） public static void binarySearch(int a[], int find)&#123; int mid = a.length/2; if(a[mid] == find)&#123; System.out.print("找到了,第"+(mid+1)+"位"); return; &#125; int left = 0; int right = a.length-1; while(left &lt;= right)&#123; mid = (left+right)/2; if(a[mid] == find)&#123; System.out.print("找到了,第"+(mid+1)+"位"); return; &#125;else if(find &lt; a[mid])&#123; right = mid-1; &#125;else if(find &gt; a[mid])&#123; left = mid+1; &#125; &#125; System.out.print("没找到"); &#125;&#125; PHP代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?php//冒泡排序法function bubbleSort($arr)&#123; if(!is_array($arr)) return; $temp=0; for($i=1;$i&lt;count($arr);$i++)&#123; for($j=0;$j&lt;count($arr)-1;$j++)&#123; if($arr[$j]&lt;$arr[$j+1])&#123; $temp = $arr[$j+1]; $arr[$j+1] = $arr[$j]; $arr[$j] = $temp; &#125; &#125; &#125; return $arr;&#125;//选择排序法1function selectSort($arr)&#123; if(!is_array($arr)) return; for($i=0;$i&lt;count($arr)-1;$i++)&#123; $x=$arr[$i];$y=$i; for($j=$i+1;$j&lt;count($arr);$j++)&#123; if($x &lt; $arr[$j])&#123; $x=$arr[$j]; $y=$j; &#125; &#125; if($x != $arr[$i])&#123; $arr[$y] = $arr[$i]; $arr[$i] = $x; &#125; &#125; return $arr;&#125;//选择排序法2function selectSort1($arr)&#123; if(!is_array($arr)) return; $temp=0; for($i=0;$i&lt;count($arr)-1;$i++)&#123; for($j=$i+1;$j&lt;count($arr);$j++)&#123; if($arr[$i] &lt; $arr[$j])&#123; $temp = $arr[$j]; $arr[$j] = $arr[$i]; $arr[$i] = $temp; &#125; &#125; &#125; return $arr;&#125;//插入排序法function insertSort($arr)&#123; if(!is_array($arr)) return; for($i=1;$i&lt;count($arr);$i++)&#123; if($arr[$i] &gt; $arr[$i-1])&#123; $x = $arr[$i]; $y = $i-1; while($y &gt;= 0 &amp;&amp; $x&gt;$arr[$y])&#123; $arr[$y+1] = $arr[$y]; $y--; &#125; $arr[$y+1] = $x; &#125; &#125; return $arr;&#125;//二分法查找(递归算法)function binarySearch($arr, $left, $right, $find)&#123; if(!is_array($arr)) return; if($right &gt;= $left)&#123; $mid = floor(($left+$right)/2); if($arr[$mid] == $find)&#123; return $mid; &#125; if($arr[$mid] &gt; $find)&#123; return binarySearch($arr, $left, $mid-1, $find); &#125; if($arr[$mid] &lt; $find)&#123; return binarySearch($arr, $mid+1, $right, $find); &#125; &#125; &#125;//二分法查找（循环算法）function binarySearch1($arr, $find)&#123; if(!is_array($arr)) return; $mid = floor(count($arr)/2); if($arr[$mid] == $find)&#123; return $mid; &#125; $left = 0; $right = count($arr)-1; while($left &lt;= $right)&#123; $mid = floor(($left+$right)/2); if($arr[$mid] == $find)&#123; return $mid; &#125;elseif($arr[$mid] &gt; $find)&#123; $right = $mid-1; &#125;elseif($arr[$mid] &lt; $find)&#123; $left = $mid+1; &#125; &#125;&#125;//$arr = array(2,10,333,11,1,22,100,20);//$arr = bubbleSort($arr);$arr = array(1,2,3,4,5,6,7,8,9,10);$arr = binarySearch1($arr,7);echo "&lt;pre&gt;";print_r($arr);?&gt; 其他不怎么经常见到的算法，改天再研究！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何安装Composer]]></title>
      <url>%2F2017%2F03%2F04%2Fphp-composer%2F</url>
      <content type="text"><![CDATA[Composer 是 PHP5以上的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。比如：Laravel框架，yii框架都必须安装composer才能使用，下面说说composer如何安装。 第一步安装前请务必确保已经正确安装了 PHP。打开命令行窗口并执行 php -v 查看是否正确输出版本号。 第二步打开命令行并执行下列命令安装最新版本的 Composer (以下指令摘自 https://getcomposer.org/download/ ，请前往查看最新的安装指令)：123php -r "readfile('https://getcomposer.org/installer');" &gt; composer-setup.phpphp composer-setup.phpphp -r "unlink('composer-setup.php');" 执行第一条命令下载下来的 composer-setup.php 脚本将简单的检测 php.ini 中的参数设置，如果某些参数未正确设置则会给出警告；然后下载最新版本的 composer.phar 文件到当前目录。上述 3 条命令的作用依次是：下载安装脚本 － composer-setup.php － 到当前目录。执行安装过程。删除安装脚本。 第三步局部安装上述下载 Composer 的过程正确执行完毕后，可以将 composer.phar 文件复制到任意目录（比如项目根目录下），然后通过 php composer.phar 指令即可使用 Composer 了！ 全局安装全局安装是将 Composer 安装到系统环境变量 PATH 所包含的路径下面，然后就能够在命令行窗口中直接执行 composer 命令了。 Mac 或 Linux 系统：打开命令行窗口并执行如下命令将前面下载的 composer.phar 文件移动到 /usr/local/bin/ 目录下面：1sudo mv composer.phar /usr/local/bin/composer Windows 系统：找到并进入 PHP 的安装目录（和你在命令行中执行的 php 指令应该是同一套 PHP）。将 composer.phar 复制到 PHP 的安装目录下面，也就是和 php.exe 在同一级目录。在 PHP 安装目录下新建一个 composer.bat 文件，并将下列代码保存到此文件中。1@php "%~dp0composer.phar" %* 最后重新打开一个命令行窗口试一试执行 composer –version 看看是否正确输出版本号。 最后提示：不要忘了经常执行 composer selfupdate 以保持 Composer 一直是最新版本哦！ 如果觉得命令行安装麻烦可以用下面的傻瓜式安装（windows平台）下载并且运行 Composer-Setup.exe，它将安装最新版本的 Composer ，并设置好系统的环境变量，因此你可以在任何目录下直接使用 composer 命令。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[__FILE__与__DIR__与 getcwd()与$_SERVER['SCRIPT_FILENAME']之间的区别]]></title>
      <url>%2F2017%2F02%2F25%2Fphp-other%2F</url>
      <content type="text"><![CDATA[要获取当前php脚本所在目录的绝对路径，可以下面通过四个方法：1、 __FILE__2、 __DIR__3、getcwd()4、$_SERVER[‘SCRIPT_FILENAME’]下面通过实例来说明之间的区别：脚本路径：D:\Soft\xampp\htdocs\test\test.php，代码如下：123456789101112131415161718192021&lt;?php//PHP获取绝对路径方法比较//__FILE__ vs __DIR__ vs getcwd() vs $_SERVER['SCRIPT_FILENAME']echo '===============当前执行脚本=================&lt;br/&gt;';$a = __FILE__;$b = __DIR__;$c = getcwd();$d = $_SERVER['SCRIPT_FILENAME'];echo '__FILE__='.$a.'&lt;br/&gt;';echo '__DIR__='.$b.'&lt;br/&gt;';echo 'getcwd()='.$c.'&lt;br/&gt;';echo '$_SERVER["SCRIPT_FILENAME"]='.$d.'&lt;br/&gt;';echo '===============被包含文件===================&lt;br/&gt;';include 'include/inc.php';?&gt; 脚本路径：D:\Soft\xampp\htdocs\test\include\inc.php，代码如下：123456789101112131415&lt;?php//PHP获取绝对路径方法比较//__FILE__ vs __DIR__ vs getcwd() vs $_SERVER['SCRIPT_FILENAME']$a = __FILE__;$b = __DIR__;$c = getcwd();$d = $_SERVER['SCRIPT_FILENAME'];echo '__FILE__='.$a.'&lt;br/&gt;';echo '__DIR__='.$b.'&lt;br/&gt;';echo 'getcwd()='.$c.'&lt;br/&gt;';echo '$_SERVER["SCRIPT_FILENAME"]='.$d;?&gt; 运行结果如下：1234567891011===============当前执行脚本=================__FILE__=D:\Soft\xampp\htdocs\test\test.php__DIR__=D:\Soft\xampp\htdocs\testgetcwd()=D:\Soft\xampp\htdocs\test$_SERVER["SCRIPT_FILENAME"]=D:/Soft/xampp/htdocs/test/test.php===============被包含文件===================__FILE__=D:\Soft\xampp\htdocs\test\include\inc.php__DIR__=D:\Soft\xampp\htdocs\test\includegetcwd()=D:\Soft\xampp\htdocs\test$_SERVER["SCRIPT_FILENAME"]=D:/Soft/xampp/htdocs/test/test.php复制代码 结论：getcwd()获取的是当前运行脚本的目录，不管getcwd()是在被包含的文件里面还是在当前执行脚本文件里面，运行的结果不会发生任何变化。__FILE__获取的是文件名称，如果用在被包含文件中，则返回被包含的文件名，如果直接用在当前运行脚本里面，则返回运行脚本的文件名称。__DIR__获取的是文件名称目录，如果用在被包含文件中，则返回被包含的文件名目录，如果直接用在当前运行脚本里面，则返回运行脚本的文件名称目录。 $_SERVER[‘SCRIPT_FILENAME’]获取的是当前运行脚本名称，不管$_SERVER[‘SCRIPT_FILENAME’]是在被包含的文件里面还是在当前执行脚本文件里面，运行的结果不会发生任何变化。 区别：dirname($_SERVER[‘SCRIPT_FILENAME’])与getcwd()效果一样，是获取当前运行脚本的目录。 dirname(__FILE__)与__DIR__效果一样，获取的是文件名称目录，如果用在被包含文件中，则返回被包含的文件名目录，如果直接用在当前运行脚本里面，则返回运行脚本的文件名称目录。__DIR__是php5.3.0之后新增的，dirname与__FILE__是php4.0.2开始启用，效率上来说__DIR__比dirname(__FILE__)更高，如果php版本是5.3以上的，建议使用__DIR__，否则还是使用dirname(__FILE__)合适，避免程序出错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php zip文件类操作实例]]></title>
      <url>%2F2017%2F02%2F22%2Fphp-zip%2F</url>
      <content type="text"><![CDATA[这些天闲着无聊搞一下php解压zip文件，自己动手写了一个zip封装程序。这里涉及到的知识主要是以下几个zip函数。 zip_open()123zip_open(filename)zip_open() 函数打开 ZIP 文件以供读取。如果成功，则返回 zip 文件档案资源。如果失败，则返回 false zip_read()123zip_read(zip)zip_read() 函数读取打开的 zip 档案中的下一个文件。如果成功，则返回包含 zip 档案中一个文件的资源。如果没有更多的项目可供读取，则返回 false。 zip_entry_open()12zip_entry_open(zip,zip_entry,mode)zip_entry_open() 函数打开一个 ZIP 档案项目以供读取。 zip_entry_read()123zip_entry_read(zip_entry,length)zip_entry_read() 函数从打开的 zip 档案项目中获取内容。如果成功，则返回项目的内容。如果失败，则返回 false。 zip_entry_name()12zip_entry_name(zip_entry)zip_entry_name() 函数返回 zip 档案项目的名称。 zip_entry_filesize()12zip_entry_filesize(zip_entry)zip_entry_filesize() 函数返回 zip 档案项目的原始大小（在压缩之前）。 zip_entry_close()12zip_entry_close(zip_entry)zip_entry_close() 函数关闭由 zip_entry_open() 函数打开的 zip 档案文件。 zip_close()12zip_close(zip)zip_close() 函数关闭由 zip_open() 函数打开的 zip 档案文件。 下面是zip的封装函数实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass zip&#123; private $zip; private $savepath; public function __construct($zipname = null) &#123; $zipname &amp;&amp; $this-&gt;open($zipname); &#125; public function open($zipname)&#123; if(!is_file($zipname))&#123; exit('this zip file no exit'); &#125; $this-&gt;zip = zip_open($zipname); if(!$this-&gt;zip)&#123; exit('this zip file is not valid'); &#125; return $this; &#125; //$savepath默认是当前根目录 public function save($savepath = './')&#123; if(!$this-&gt;zip)&#123; exit('this zip file is unopen'); &#125; if($savepath)&#123; $this-&gt;savepath = $savepath; &#125; while ($zip_entry = zip_read($this-&gt;zip))&#123; $name = $this-&gt;mkdirs(zip_entry_name($zip_entry)); if ($name &amp;&amp; zip_entry_open($this-&gt;zip, $zip_entry))&#123; $contents = zip_entry_read($zip_entry, zip_entry_filesize($zip_entry)); if($contents)&#123; file_put_contents($name, $contents); &#125; zip_entry_close($zip_entry); &#125; &#125; zip_close($this-&gt;zip); &#125; public function mkdirs($path)&#123; $dir = $this-&gt;savepath .'/'. dirname($path); if(is_dir($dir))&#123; return $this-&gt;savepath .'/'. $path; &#125; if(mkdir($dir, 0777, true))&#123; return $this-&gt;savepath .'/'. $path; &#125; else &#123; return false; &#125; &#125;&#125;$zip = new zip();//打开一个test.zip文件，解压到当前目录$zip-&gt;open('test.zip')-&gt;save();//打开一个test.zip文件，解压到当前目录下的zip目录$zip-&gt;open('test.zip')-&gt;save('./zip/');?&gt; 总结php操作zip文件还是挺简单的，需要用到的函数也不是很多。如要有需要的话直接拿来用接可以了，简单方便，如果有时间的话再弄一个在线解压小程序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo+github教程之Markdown工具-MarkdownPad]]></title>
      <url>%2F2016%2F12%2F28%2Fhexo-github-6%2F</url>
      <content type="text"><![CDATA[前面五个hexo+github教程，我们已经把hexo博客的搭建，主题优化，还有第三方插件的安装都撸过一遍了，相信看过教程的应该都能搭建出一个满意的hexo博客了。好了，言归正传，这一篇博文是介绍Markdown工具–MarkdownPad2 简介MarkdownPad是Windows下的一个多功能Markdown编辑器。可以边编辑边预览（再也不用各种切换到浏览器上查看样式了），有可视化工具栏，有快捷键，可以很方便快捷的写出自己想要的博文。据说是windows平台上最好用的Markdown工具，没有之一。 安装点击MarkdownPad下载安装。MarkdownPad有免费版和专业版（好像没感觉出来免费版和专业版有什么区别），专业版需要激活码。这里附上网上可用的激活码：1234邮箱：Soar360@live.com授权秘钥：GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 安装到最后会有提示选择版本的，如果选free则不要输入激活码。 可能会出现的问题MarkdownPad2在windows10系统下会出现无法预览的问题，需要安装官方提供的补丁， Awesomium 1.6.6 SDKwindows7系统没有这个问题，可以不用安装补丁。MarkdownPad编辑器很简洁，上手很快，基本上没有难度，也不用看什么教程，也不用配置什么，默认配置就可以了，如果还想挖掘MarkdownPad还有什么实用功能可以自己一个试一下，说不定会有什么发现。 MarkdownPad快捷键12345678910111213Bold(加粗) Ctrl+BEmphasize(斜体) Ctrl+IBlockquote(引用) Ctrl+QCode(代码) Ctrl+KH1(h1标题) Ctrl+1H2(h2标题) Ctrl+2H3(h3标题) Ctrl+3Link(链接) Ctrl+LImage(图片) Ctrl+GUnordered List(无序) Ctrl+UOrdered List(有序) Ctrl+Shift+OTimestamp(时间) Ctrl+THorizontal Rule(分割线) Ctrl+R 熟悉这些快捷键的话，基本上不用到鼠标了，可以专注码字了。好了，MarkdownPad就介绍到这里。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo+github教程之五：github配置专属域名]]></title>
      <url>%2F2016%2F12%2F27%2Fhexo-github-5%2F</url>
      <content type="text"><![CDATA[为了更好的让别人记住博客地址，我们可以购买域名来绑定github。这样就可以更便捷的访问自己的博客，也避免github的域名不稳定导致无法访问博客。 首先要购买域名推荐到阿里云购买，博主也是在阿里云购买的。域名最好是越短越好，如果想要高大上一点的就用.com，便宜有好用的可以选.top，.me之类的，.top的注册的人比较少，一般不是什么特殊域名都可以注册得到，4块钱一年，简直业界良心。 域名解析1、先登录到阿里云后台，找到域名解析，新建一个解析（这里是以阿里云DNS解析，其他的应该大同小异）2、到存放博客的github仓库，点击Setting3、在Setting下面找到GitHub Pages下面Custom domain，添加刚才购买的域名4、第三步操作完，github会自动在仓库根目录下创建CNAME文件，然后在我们博客目录D:\Blog\source下，新建一个CNAME文件，内容要跟github仓库根目录下的CNAME文件一样，就是我们解析的域名。（这一步的目的是为了防止以后我们提交github的时候删除点CNAME文件）5、打开浏览器测试一下，看看是不是已经能访问了 其他问题我之前也遇到DNS解析问题，网上很多做法是：123@ A 192.30.252.153@ A 192.30.252.154www CNAME username.github.io. 但是我测试是有问题的，去除两个A记录就可以正常了，只需要一个CNAME解析就可以了。 结语搞hexo博客花了两天时间，写这几篇教程也花了两天，不过终于写完了。。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo+github教程之四：配置hexo next主题第三方插件]]></title>
      <url>%2F2016%2F12%2F27%2Fhexo-github-4%2F</url>
      <content type="text"><![CDATA[到了这一步，基本上已经拥有了一个很perfect的博客了，但是还是缺少一点第三方插件，还不算太完美。本文主要讲解几个重要的第三方插件：多说，搜索，404页面，用户访问记录，RSS和sitemap。 多说评论1、打开多说网站，登陆多说（微博或qq快捷登录），创建站点。2、按下图进行输入创建评论站点。站点名称可以随便填，站点域名就填写博客域名，多说域名填写blog名，这个主题配置到时会用到（多说的short_name）3、创建完以后进入管理后台，在左侧菜单栏里找到工具，右侧代码里看到short_name，也就是刚才输入的多说域名。4、打开 主题配置文件（themes\next\_config.yml），找到 duoshuo_shortname，写到后面。不同主题可能名字不一样，操作都是一样的。1duoshuo_shortname: tenke 5、设置多说评论显示UA以及博主，在主题配置文件找到以下配置12345duoshuo_info: ua_enable: true #是否显示ua admin_enable: true #是否显示博主 user_id: 123456789 #多说用户id admin_nickname: Tenken #博主昵称自定义 多说的用户id其实就是用户秘钥，如图：如果想要开启多说分享的，可以找到以下配置:1duoshuo_share: true 好，多说评论配置完了，可以在本地查看一下是否已经生效了。12$ hexo clean$ hexo s -g 博文搜索hexo next主题有很多第三方搜索：Swiftype,微搜索,Local Search,Algolia这四种，这里我选择Local Search，至于原因就是这个比较简单，其他的都要申请账号什么的，麻烦。1、安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：1$ npm install hexo-generator-searchdb --save 2、编辑 站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 配置好，重新启动一下hexo12$ hexo clean$ hexo s -g 应该会看到: 配置404页面404页面，我们选择腾讯公益404页面。在 hexo/source 文件夹下新建404.html。编辑404.html页面，输入以下代码，保存。123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="your site url " homePageName="回到我的主页"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 还要在站点配置文件开启404页面配置才能在博客页面看见404入口12345678menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / categories: /categories #分类 tags: /tags #标签 archives: /archives #归档 about: /about # 关于我 #sitemap: /sitemap.xml #这个可以不用开启，给搜索引擎用的，需要安装插件 commonweal: /404.html #公益404 记得每次修改站点配置文件需要重启hexo服务12$ hexo clean$ hexo s -g 用户访问记录next主题有两个用户访问记录的插件，leancloud_visitors和busuanzi_count，leancloud_visitors这个需要到https://leancloud.cn注册获取AppID and AppKey，那么我们就选择busuanzi_count这个插件。打开主题配置文件，找到以下配置，设置为true就可以了123456789101112131415busuanzi_count: #第三方用户访问插件，直接开启 # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp阅读数 page_pv_footer: RSS和sitemap1、安装RSS和sitemap插件12npm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 2、开启RSS和sitemap功能，编辑站点配置文件 hexo/_config.yml1234feed: type: atom #feed 类型 path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有) NexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 主题配置文件，设定 rss 字段的值： false：禁用 RSS，不在页面上显示 RSS 连接。 留空：使用 Hexo 生成的 Feed 链接。 具体的链接地址：适用于已经烧制过 Feed 的情形。 这里我们留空就行了。 到此，next的第三方插件就配置完了，如果还想要其他插件的请参考next配置文档下一步开始配置github域名···]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo+github教程之三：hexo next主题配置]]></title>
      <url>%2F2016%2F12%2F27%2Fhexo-github-3%2F</url>
      <content type="text"><![CDATA[到了这一步，相信你们都已经搭建好hexo博客，以及配置好github。下面开始讲解hexo主题配置。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 安装NexT主题Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 1、安装主题1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 2、启动主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 3、验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse现在，你已经成功安装并启用了 NexT 主题。 hexo 站点配置文件我们打开站点下的_config.yml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: Tenken blog #网站标题subtitle: 爱好游戏的码农 #网站副标题description: 各种宅，各种懒，爱好游戏的码农 #网站描述author: Tenken #博主的名字language: zh-Hans #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。url: http://whatcode.cn # 你网站的urlpermalink: :year/:month/:day/:title/ #生成文件名字的格式我改成blog/:title:year:month:day/permalink_defaults:# Directory 目录配置source_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。# Writing 文章new_post_name: :title.md # 新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类和标签的设置default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next ## hexo主题## Rssfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有)# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:Tenke007/Tenke007.github.io.git branch: master 上面的备注都很清楚了，基本没有什么需要更改的，网站title等根据自己修改就可以了。下面开始说说主题配置文件（重点） hexo 主题配置文件我们打开D:\Blog\themes\next下的_config.yml文件，下面会有中文注释1、开启侧边栏社交链接12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等 2、开启打赏功能123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 3、开启友情链接1234links_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 4、多说评论显示 UA12345678# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: true user_id: 123456 admin_nickname: Tenken 5、开启订阅微信公众号1234wechat_subscriber: enabled: true qcode: /uploads/wechat-qcode.jpg description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 6、站点建立时间1since: 2013 7、设置头像1avatar: http://example.com/avtar.png 8、选择 Scheme123#scheme: Muse#scheme: Mistscheme: Pisces 下面是_config.yml文件的全部配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico #站标 可以放在hexo文件夹下的/source里# Set default keywords (Use a comma to separate)keywords: "Tenken, Tenken blog, whatcode.cn, greeghost.com" ##网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: #rss这里不设置 站点配置文件已经配置了 需要安装插件# Specify the date when the site was setupsince: 2015 网站时间 从xx开始 类似 2015-2016# icon between year and author @Footerauthoricon: heart# Footer `powered-by` and `theme-info` copyrightcopyright: true# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remeber set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / categories: /categories #分类 tags: /tags #标签 archives: /archives #归档 about: /about # 关于我 #sitemap: /sitemap.xml #这个可以不用开启，给搜索引擎用的，需要安装插件 commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #上面menu的icon enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next主题的三个schemes(默认是Muse)#scheme: Muse#scheme: Mistscheme: Pisces# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal intalic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)#social: #社交链接，可以放github,weibo,qq等 #LinkLabel: Link #GitHub: https://github.com/Tenke007 #Wechat: /images/wechat.png# Social Links Icons# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of the item and value is the name of FontAwsome icon. Key is case-senstive.# When an globe mask icon presenting up means that the item has no mapping icon.social_icons: #对应的社交icon enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo Wechat: wechat# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: /images/avatar.jpg #博主头像（可以放外链）# Table Of Contents in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: true# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: #侧边栏，貌似只对scheme: Pisces有效，可以设置左边或右边 # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. display: post #display: always #display: hide #display: remove# Blogrollslinks_title: 友情链接#links_layout: blocklinks_layout: inlinelinks: 极客幽灵: http://www.greeghost.com discuz开发者: http://addon.discuz.com/?@24443.developer# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: #设置为true,首页文章会显示 阅读全文 enable: true length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Wechat Subscriber # 文章内显示微信二维码wechat_subscriber: enabled: true qcode: /images/wechat.png #微信二维码图片路径 description: 扫一扫添加微信好友 #微信二维码描述# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML# Swiftype Search API Key #第三方搜索#swiftype_key:# Baidu Analytics ID #百度分析#baidu_analytics:# Duoshuo ShortName #多说评论，需要自己注册账号duoshuo_shortname: tenke# Disqus#disqus_shortname:# Hypercomments#hypercomments_id:# Gentie productKey#gentie_productKey:# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share#jiathis:# Warning: JiaThis does not support https.#add_this_id:# Share #多说分享，上面有百度分享，jiathis分享，因为我开启了多说，所以这里我只有多说分享duoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: #多说配置 ua_enable: true #开启显示UA admin_enable: true #是用于显示 「博主」 文字 user_id: 123456 #多说账号的秘钥 admin_nickname: Tenken #博主名字# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: #第三方用户访问插件，直接开启 # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp阅读数 page_pv_footer:# Tencent analytics ID# tencent_analytics:## 打赏reward_comment: 请我吃辣条吧~~wechatpay: /images/wxpay.pngalipay: /images/alipay.jpg# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.0 上面的是本博客hexo next的主题配置文件，各位可以参考一下。下一步重点讲解如何配置第三方插件，如：多说评论，搜索，RSS，404页面等 请参考next主题文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo+github教程之二：hexo博客发布到github]]></title>
      <url>%2F2016%2F12%2F26%2Fhexo-github-2%2F</url>
      <content type="text"><![CDATA[上一篇教程已经把hexo博客安装好在本地了，但是只能在本地访问，现在我们要将博客部署到github上。 一、github注册及配置1、首先我们先去准备github ,（点击文字进行跳转）。2、首先在主界面注册github进行！按照步骤进行注册。3、注册成功先不要急！此时我们还需要验证邮箱地址。4、接下来我们需要建立一个仓库。记住建立仓库时所填写的内容！是你的帐号.github.io（这是因为github规定的格式这样才会直接讲当前仓库作为托管站点）比如：Tenke007.github.io(这个是我的仓库)5、到你刚刚创建的Repository下，复制Repository的地址（ssh格式） 二、修改hexo的配置文件1、打开_config.yml文件（在博客目录下）2、修改文件里面的deploy。其中的repository就改成你刚刚复制的地址。保存这个文件。1234deploy: type: git repository: git@github.com:Tenke007/Tenke007.github.io.git branch: master 注意：repository改成你刚刚复制的地址 三、设置SSH keys1、在Git Bash输入以下指令（任意位置点击鼠标右键），检查是否已经存在了SSH keys。1ls -al ~/.ssh 2、如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件：3、输入以下指令（邮箱就是你注册Github时候的邮箱）后，回车：1ssh-keygen -t rsa -C "angelen10@163.com" 4、然后它会提示要你输入passphrase（如上图，我没有输入直接回车，如果你输入的话，要记得，到时候会用到）。之后，如果出现类似下图：5、然后键入以下指令：1ssh-agent -s 6、继续输入指令：1ssh-add ~/.ssh/id_rsa 7、输入之后，在我这里是出错了，不知道你的有没有出错。8、如果你的也是这样子出错了的话，就输入以下指令：12eval `ssh-agent -s`ssh-add 9、到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：1clip &lt; ~/.ssh/id_rsa.pub 10、然后到Github里面，点击右上角的设置图标：在Settings sidebar那里，点击SSH keys：点击Add SSH key：11、输入Title，作为这个key的描述吧（你可以输入Personal MacBook Air，瞬间高大上）然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开以下文件）：点击Add Key12、输入你的Github密码即可完成SSH Key的添加。嗯，最后还是测试一下吧，键入以下命令：1ssh -T git@github.com 你可能会看到有警告，没事，输入“yes”就好。 三、开始部署输入以下命令123hexo cleanhexo ghexo d 如果出现error deployer not found:github错误，执行以下命令1npm install hexo-deployer-git --save Okay,我们的博客已经完全搭建起来了，在浏览器访问 https://tenke007.github.io 就能看到你的成就了！ 还有一点，有一些用户在hexo deploy之后会有个这个提示那么我们要输入我们在git上验证的邮箱如这样。再次 hexo deploy如出现以下这种提示应该就发布上去了。12345The file will have its original line endings in your working directory.Branch master set up to track remote branch master from git@github.com:Tenke007/Tenke007.github.io.git.To git@github.com:Tenke007/Tenke007.github.io.git 8cfeb05..b8bd0f3 HEAD -&gt; masterINFO Deploy done: git tipshexo现在支持更加简单的命令格式了，比如：1234hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 本文图片来源于其他互联网站点，可能显示部分有点不一样，后续我会把图片放到云盘上，例如七牛云盘]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo+github教程之一：搭建hexo博客]]></title>
      <url>%2F2016%2F12%2F26%2Fhexo-github-1%2F</url>
      <content type="text"><![CDATA[前言本人几年前就想搭建一个属于自己的博客，刚好前段时间看见很多大神都用hexo搭建自己的个人博客，于是乎自己也动手折腾了一番，搞了两天终于弄出一个还过得去的博客。废话不多说，下面开始动手！ 第一步1、git下载与安装git的下载安装应该没什么难度，不知道git怎么下载的请自行度娘，反正安装的时候一直默认配置就行了，一直next。安装好后，鼠标右键任意地方应该会出现如图，就说明已经安装成功了。 2、安装node.jsnode.js的官网好像被墙了，反正我是费了好大劲才下载好。node.js地址，选择最新版本。然后也是一路next就行了。 第二步（开始正题）1、鼠标右键任意地方，选择Git Bash ，使用以下命令安装hexo(ps：以下命令中的$符号只为了让教程和实际看起来一致，实际输入命令只需输入$后面的命令即可)1$ npm install -g hexo 执行完命令应该会有C:\Users\Administrator\AppData\Roaming\npm这个目录。 2、创建一个或者选择一个目录来放博客文件，如我的目录：D:\Blog，名字和地方可以自由选择，当然最好不要放在中文路径下。然后在博客文件夹鼠标右键，选择Git Bash，执行以下命令，Hexo会自动在该文件夹下下载搭建网站所需的所有文件。1$ hexo init 接着安装依赖包1$ npm install 执行完看看博客目录，应该有文件生成了。 3、执行下面命令就可以在本地看到hexo博客了12$ hexo g$ hexo s 然后用浏览器访问http://localhost:4000/，此时，你应该看到了一个漂亮的博客了，当然这个博客只是在本地的，别人是看不到的，hexo3.0使用的默认主题是landscape。轻轻松松就看到了一点成果，是不是很激动，这就是hexo的强大之处，这个本地预览的功能，我真是爱不释手。自己可以发一篇新的文章12$ hexo new 'test'$ hexo s -g 你会发现多了一篇叫‘test’的文章，在D:/Blog/source/_posts下会有test.md文件（需要学习markdown语法） 到此，hexo博客算是搭建成功了，但是只能在本地看，下一步，我们把它部署到github上。附上我的blog: 放在github上的whatcode.cn,放在阿里云的blog.greeghost.com。放在github上的相对慢一点，但是作为blog空间还过得去，好处是域名可以不用备案。]]></content>
    </entry>

    
  
  
</search>
